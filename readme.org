#+TODO: TODO EXPLAIN CLEAN | DONE
* Todo [33%]

- [ ] create the unit tensor operator and check that it plays well
- [X] create an option to disallow contractions of the tensor with
  itself.
- [X] create an option for only allowing linked contractions
- [ ] implement symmetry filter:
  Viajb should be the same as Vaibj and so on.
  So the symmetry is a node Vertauschungssymmetrie.
- [ ] compile with gcl
- [ ] test with clasp (it takes too long to compile in nixos)

* Prolog

#+begin_src lisp :tangle t.lisp
;; todo define packages and all that
(load "gunu.lisp")

(defmacro assert-equal (left right)
  `(assert (equal ,left ,right)))

(defmacro assert! (expr &rest args)
  `(assert (not ,expr) ,@args))

(defmacro assert!-equal (left right)
  `(assert (not (equal ,left ,right))))

(defmacro assert-condition (expr condition-type &rest body)
  `(handler-case (progn ,expr
                        (assert nil))
     (,condition-type ,@body)))

(defmacro assert-errmsg (expr condition-type error-message)
  `(assert-condition ,expr ,condition-type
                     (m) (assert-equal (format nil "~a" m)
                                       ,error-message)))
#+end_src

#+RESULTS:
: ASSERT-CONDITION

* Nomenclature

In order to read better the code and organize it better, we
should begin by having a clear nomenclature of the objects
we are dealing with.

A diagram is in its graph-theoretic sense
a set of nodes with vertices.
In the case of a diagram in chemistry a vertex is
interpreted as a contraction and /uncontracted vertices/
are legs of a diagram.

We will not make the distinction between a legged-node
and an unlegged-node, as we do not need it for our purposes.

Therefore, a simple picture of a diagram can be akin to the
following representation:

#+begin_example
\
 \
  \         v------------- Node
   *========*
  /          \
 /            \ <--------- Leg 
/              \
#+end_example

** Types

In Lisp, we will represent a short list of objects in the following
manner:

- A tensor
  #+begin_src lisp
  (tensor-name [node])
  #+end_src
- A contracted expression
  #+begin_src lisp
  ((contraction (point-1 point-2)) (tensor-product))
  #+end_src

These conceps are simply represented as simple lisp predicates
as follows
#+begin_src lisp :tangle gunu.lisp
(defun contraction? (expr)
  (and (listp expr)
       (listp (car expr))
       (eq (caar expr) 'contraction)
       ;; body
       (listp (cadr expr))))

(defun tensor? (expr)
  (and (listp expr)
       (listp (cadr expr))))
#+end_src

#+begin_src lisp :tangle t.lisp
(assert (contraction? '((contraction ((a b) (c d))) nil)))
(assert (contraction? '((contraction nil) ((t (a i) (b j))))))
(assert (tensor? '(t (a i) (b j))))
(assert (tensor? '(1 nil)))
(assert (tensor? '(0 nil)))
#+end_src


* Main variables

The following variables act as flags for the behaviour of the program,
you can set them temporarily in a `let` block in order to use them
or set them globally with `setq`.

** Verbosity and logging
To control the verbosity of the program, set the =*print-log*=
variable.

#+begin_src lisp  :tangle gunu.lisp
(defvar *print-log* t
  "Wether to print the log messages for the contractions and so on")

;; TODO: implement log levels
(defmacro logger (fmt &rest args)
  `(when *print-log*
    (eval (format t ,fmt ,@args))))
#+end_src

** Contractions within the same tensor

In general, the contraction searcher will search for contractions
according to the contraction rules between all nodes.

However, for most many-body diagrammatics, one is mostly interested in
contractions between different tensors.

#+begin_src lisp :tangle gunu.lisp
(defvar *allow-self-contractions* nil
  "Wether or not to allow a tensor to search for contractions with its
  nodes.")
#+end_src

If you want to allow self-contractions you can set this option as

#+begin_src lisp :eval no
(setq *allow-self-contractions* t)
#+end_src

** Connected diagrams

As in coupled-cluster theories, you can also only
look for connected contraction possibilities.

This settings is disables by default so you will
have to explicitly set it to have connected diagrams,
see the examples for coupled-cluster theories.

;; TODO: maybe this should be called linked,
;;       check with lindgren paper.
#+begin_src lisp :tangle gunu.lisp
(defvar *only-connected-diagrams* nil
  "Wether to look for contractions that create connected diagrams.")
#+end_src

#+RESULTS:
: *ONLY-CONNECTED-DIAGRAMS*



* Combinatorics

This code relies a lot on combinatorics and set-theoretic functions,
this section describes their implementation in order to maintain
the package self-contained.

** Cartesian product

We implement a cartesian product in the form of a macro
that avoids recursion but however writes it with depending
on the loop macro.

#+begin_src lisp :tangle gunu.lisp
(defmacro cartesian-product (&rest lists)
  (let* ((indices (loop for i from 1 to (length lists)
                        collect (gensym (format nil "~a-i-" i))))
         (initial-value `(loop for ,(car (last indices)) in ',(car (last lists))
                               collect `(,,@indices))))
    (reduce
     (lambda (x y)
       `(loop for ,(car x) in ',(cadr x)
              nconc ,y))
     (mapcar #'list (butlast indices) (butlast lists))
     :from-end t
     :initial-value initial-value)))
#+end_src

With tests:
#+begin_src lisp :tangle t.lisp
(assert-equal (cartesian-product (H P) (a b c) (1 2 3 5))
              '((H A 1) (H A 2) (H A 3) (H A 5)
                (H B 1) (H B 2) (H B 3) (H B 5)
                (H C 1) (H C 2) (H C 3) (H C 5)
                (P A 1) (P A 2) (P A 3) (P A 5)
                (P B 1) (P B 2) (P B 3) (P B 5)
                (P C 1) (P C 2) (P C 3) (P C 5)))

(assert-equal (cartesian-product (H (P)) ((a)))
              '((H (A)) ((P) (A))))
#+end_src

** Permutations

#+begin_src lisp :tangle gunu.lisp
(defun all-permutations (lst &optional (remain lst))
  (cond ((null remain) nil)
        ((null (rest lst)) (list lst))
        (t (append
            (mapcar (lambda (l) (cons (first lst) l))
                    (all-permutations (rest lst)))
            (all-permutations (append (rest lst) (list (first lst)))
                              (rest remain))))))
#+end_src

And tests
#+begin_src lisp :tangle t.lisp
(assert-equal (all-permutations '(a b))
              '((A B) (B A)))
(assert-equal (all-permutations '(a b c))
              '((A B C) (A C B) (B C A) (B A C) (C A B) (C B A)))
(assert-equal (all-permutations '(a b c d))
              '((A B C D) (A B D C) (A C D B) (A C B D) (A D B C) (A D C B)
                (B C D A) (B C A D) (B D A C)
                (B D C A) (B A C D) (B A D C) (C D A B) (C D B A) (C A B D)
                (C A D B) (C B D A) (C B A D)
                (D A B C) (D A C B) (D B C A) (D B A C) (D C A B) (D C B A)))
#+end_src


** Node pairs building

In order to find contractions, we will be concerned with a product
of tensors $(t_1, \ldots, t_n)$ and every tensor will have
a series of nodes, let us denote the whole indices of the nodes
from $0$ to $N - 1$ where

$$
N = \sum_i \#\mathrm{nodes}(t_i)
$$

=get-node-pairs= will give us pairs of nodes to search
for contractions in.
We have to restrict the possible pairs according to:

- only one occurrence of a pair combination is allowed
  in order not to search for the same contractions
  twice, this means that only $(i, j)$ pairs
  are allowed where $i \leq j$.
- in the case we want to search only for contractions
  between different tensors, we can provide
  a =group-lengths= list which will only
  allow for pairs of different groups.


#+begin_src lisp :tangle gunu.lisp
(defun get-node-pairs (n &key (group-lengths nil))
  ;; check that group-lengths is well built
  (when group-lengths (assert (eq n (apply #'+ group-lengths))))
  (let ((successive-lengths
          ;; successive-lengths
          ;; should be simply (g0 (+ g0 g1) ... (+ g0 .. gn))
          ;; where gj \in group-lengths
          (reverse (maplist (lambda (lst) (apply #'+ lst))
                            (reverse group-lengths)))))
    (labels ((from-i (i)
             (if group-lengths
                 ;; find the first group where i
                 ;; is smaller, this means the next group
                 ;; starts there
                 (find i successive-lengths :test #'<)
                 i)))
    (loop for i from 0 below n
        nconcing (loop for j from (from-i i) below n
                       collect `(,i ,j))))))
#+end_src

#+RESULTS:
: GET-NODE-PAIRS


#+begin_src lisp :tangle t.lisp
;; trivial examples
(assert-equal (get-node-pairs 1) '((0 0)))
(assert-equal (get-node-pairs 2) '((0 0) (0 1) (1 1)))
(assert-equal (get-node-pairs 3) '((0 0) (0 1) (0 2) (1 1) (1 2) (2 2)))

;;   2        3
;; (0 1 ||  2 3 4)
(assert-equal (get-node-pairs 5 :group-lengths '(2 3))
              '((0 2) (0 3) (0 4)
                (1 2) (1 3) (1 4)))
(assert-equal (get-node-pairs 5)
              '((0 0) (0 1) (0 2) (0 3) (0 4)
                (1 1) (1 2) (1 3) (1 4) (2 2)
                (2 3) (2 4) (3 3) (3 4) (4 4)))

;;   2        3       1       3
;; (0 1 ||  2 3 4  || 5 ||  6 7 8)
(assert-equal (get-node-pairs 9 :group-lengths '(2 3 1 3))
              '((0 2) (0 3) (0 4) (0 5) (0 6) (0 7) (0 8)
                (1 2) (1 3) (1 4) (1 5) (1 6) (1 7) (1 8)
                (2 5) (2 6) (2 7) (2 8)
                (3 5) (3 6) (3 7) (3 8)
                (4 5) (4 6) (4 7) (4 8)
                (5 6) (5 7) (5 8)))

;;   V     T1    T2
;; (0 1 || 2 || 3 4)
(assert-equal (get-node-pairs 5 :group-lengths '(2 1 2))
              '((0 2) (0 3) (0 4)
                (1 2) (1 3) (1 4)
                (2 3) (2 4)))
#+end_src

#+RESULTS:
: NIL

** Pair combinations

Given a product of tensors, we will want to have
which pair of nodes can have contractions, this is given
by the =get-node-pairs= function.
But in general we will want to have $n_c$ contractions,
taken from combinations of these node pairs =(node-a node-b)=.

For example, if we are looking for 3 contractions in total,
and we have the pairs of nodes where we can find these contractions
=(p1 ... pn)=, then we will want to look for instance
first three times in the pair of nodes =p1= for 3 successful
contractions, in pair-index notation this would represent the
list
#+begin_src lisp :eval no
(0 0 0)
#+end_src
where 0 is the index of the position of =p1= in the pair list.
We call these lists /pair combinations/.

A given /pair combination/ describes the potential connections
of the tensors and represent a whole class of diagrams.
In particular, the linkedness and connectedness of diagrams
are encoded in these lists and we use them to decide
if a given diagram is linked or not.
;; TODO: check link or connected exactly

#+begin_src lisp :tangle gunu.lisp
(defmacro ordered-subsets-with-repetition (n space-size)
  (let* ((vars (loop for i below n collect (gensym)))
         (deepest-level `(loop for ,(car (last vars))
                               from ,(car (last (butlast vars)))
                                 below ,space-size
                               collect `(,,@vars)))
         (init-var (gensym))
         (body (reduce (lambda (x y)
                         `(loop for ,(cadr x) from ,(car x) below ,space-size
                                nconcing ,y))
                       (butlast (mapcar #'list (append (list init-var)
                                                       (butlast vars))
                                        vars))
                       :initial-value deepest-level
                       :from-end t)))
    `(let ((,init-var 0))
       ,body)))
#+end_src

#+begin_src lisp :tangle t.lisp
(assert-equal (ordered-subsets-with-repetition 2 2)
              '((0 0) (0 1) (1 1)))

(assert-equal (ordered-subsets-with-repetition 2 3)
              '((0 0) (0 1) (0 2) (1 1) (1 2) (2 2)))

(assert-equal (ordered-subsets-with-repetition 2 5)
              '((0 0) (0 1) (0 2) (0 3) (0 4) (1 1) (1 2) (1 3)
                (1 4) (2 2) (2 3) (2 4) (3 3) (3 4) (4 4)))

(assert-equal (ordered-subsets-with-repetition 3 3)
              '((0 0 0) (0 0 1) (0 0 2) (0 1 1) (0 1 2)
                (0 2 2) (1 1 1) (1 1 2) (1 2 2) (2 2 2)))

;; here we would need 4 contractions between a set of
;; 4 pairs of nodes
(assert-equal (ordered-subsets-with-repetition 4 4)
              '((0 0 0 0) (0 0 0 1) (0 0 0 2) (0 0 0 3) (0 0 1 1) (0 0 1 2)
                (0 0 1 3) (0 0 2 2) (0 0 2 3) (0 0 3 3) (0 1 1 1) (0 1 1 2)
                (0 1 1 3) (0 1 2 2) (0 1 2 3) (0 1 3 3) (0 2 2 2) (0 2 2 3)
                (0 2 3 3) (0 3 3 3) (1 1 1 1) (1 1 1 2) (1 1 1 3) (1 1 2 2)
                (1 1 2 3) (1 1 3 3) (1 2 2 2) (1 2 2 3) (1 2 3 3) (1 3 3 3)
                (2 2 2 2) (2 2 2 3) (2 2 3 3) (2 3 3 3) (3 3 3 3)))
#+end_src

** Utils

#+begin_src lisp :tangle gunu.lisp
;; functions taken from uruk
(defun flatten-list (ls)
  (cond
    ((and (consp ls)
          (atom (car ls)))
     `(,(car ls) ,@(flatten-list (cdr ls))))
    ((and (consp ls)
          (consp (car ls)))
     `(,@(flatten-list (car ls)) ,@(flatten-list (cdr ls))))
    (t ls)))

(defmacro thread-first (var &rest forms)
  (let ((init var))
    (loop for f in forms
          do (setf init (setf f (cons (car f)
                                      (cons init (cdr f))))))
    init))

(defmacro thread-last (var &rest forms)
  (let ((init var))
    (loop for f in forms
          do (setf init (setf f (cons (car f)
                                      (reverse (cons init
                                                     (reverse (cdr f))))))))
    init))
#+end_src

#+RESULTS:
: THREAD-LAST

#+begin_src lisp :tangle t.lisp
(multiple-value-bind (expression _ )
    (macroexpand '(thread-first x (+ 5) (* 8)))
  (assert-equal '(* (+ x 5) 8)
                expression))
#+end_src

#+begin_src lisp :tangle gunu.lisp
(defun symbols-repeated-p (lst)
  (let ((symbols (flatten-list lst))
        s)
    (loop while (setq s (pop symbols))
          if (> (count s symbols) 0)
            do (return t))))
#+end_src

#+begin_src lisp :tangle t.lisp
(let ((vals '(((a b c) . nil)
              ((a (a) b c) . t)
              ((((a)) ((b e f g)) ((((b))))) . t))))
  (loop for (lst . val) in vals
        do (assert (eq (symbols-repeated-p lst) val))))
#+end_src

* Arithmetic expressions


#+begin_src lisp :tangle gunu.lisp
(defun expression-to-lists (exp)
  (ecase (car exp)
    ('* (let ((operands
                (mapcar (lambda (e) (case (car e)
                                      ('+ (cdr e))
                                      (t (list e))))
                        (cdr exp))))
          operands))))
#+end_src

#+begin_src lisp :tangle t.lisp
(assert-equal
 (expression-to-lists '(* (v (a i))
                        (+ 1 (t (a i)) (t (a i) (b j)))
                        (+ (r (g i)) (r (g i) (a j)))))
 '(((V (A I)))
   (1 (T (A I)) (T (A I) (B J)))
   ((R (G I)) (R (G I) (A J)))))
#+end_src

#+begin_src lisp :tangle gunu.lisp
(defun expand-expression (expr)
  (eval `(cartesian-product ,@(expression-to-lists expr))))
#+end_src

#+begin_src lisp :tangle t.lisp
(assert-equal
 (expand-expression '(* (v (a i))
                      (+ 1 (t (a i)) (t (a i) (b j)))
                      (+ (r (g i)) (r (g i) (a j)))))
 '(((V (A I)) 1 (R (G I)))
   ((V (A I)) 1 (R (G I) (A J)))
   ((V (A I)) (T (A I)) (R (G I)))
   ((V (A I)) (T (A I)) (R (G I) (A J)))
   ((V (A I)) (T (A I) (B J)) (R (G I)))
   ((V (A I)) (T (A I) (B J)) (R (G I) (A J)))))
#+end_src

* Index spaces
#+begin_src lisp :tangle gunu.lisp
(defun match-index-to-space (index orbital-space)
  (find index (cdr orbital-space)))
#+end_src

#+begin_src lisp :tangle t.lisp
(progn (assert (match-index-to-space 'k '(H i j k l)))
       (assert (not (match-index-to-space 'H '(H i j k l)))))
#+end_src

#+begin_src lisp :tangle gunu.lisp
(defun find-space-by-leg (index orbital-spaces)
  (find index orbital-spaces :test #'match-index-to-space))
#+end_src

#+begin_src lisp :tangle t.lisp
(progn (assert (equal (find-space-by-leg 'k '((P a b c) (H i j k l)))
                      '(H I J K L)))
       (assert (not (find-space-by-leg 'a '((H i j k l))))))
#+end_src

#+begin_src lisp :tangle gunu.lisp
(defun find-space-by-name (name orbital-spaces)
  (find name orbital-spaces :key #'car))

(defun find-space-name-by-leg (leg orbital-spaces)
  (car (find leg orbital-spaces :test #'match-index-to-space)))
#+end_src

#+begin_src lisp :tangle t.lisp
(assert-equal
 (find-space-by-name 'p '((PQ p q r s) (p a b c)))
 '(p a b c))
#+end_src

#+begin_src lisp :tangle t.lisp
(let ((spaces '((H k l i) (P a b c) (PQ p q r s)))
      (vals '((i . h)
              (p . pq)
              (q . pq)
              (b . p))))
  (loop for (v . result) in vals
        do (assert (eq (find-space-name-by-leg v spaces) result))))
#+end_src


* Tensor matching

#+begin_src lisp :tangle gunu.lisp
(defun match-target-with-tensor-1 (target tensor &key orbital-spaces)
  (assert (eq (length target) (length tensor)))
  (notany #'null
          (loop for target-tensor in (mapcar #'list (cdr target) (cdr tensor))
                collect
                (let ((spaces (mapcar (lambda (i) (find i orbital-spaces :key #'car))
                                      (car target-tensor))))
                  (assert (eq (length (car target-tensor)) (length (cadr target-tensor))))
                  (notany #'null (mapcar #'match-index-to-space
                                         (cadr target-tensor)
                                         spaces))))))
#+end_src

#+begin_src lisp :tangle t.lisp
(progn
  (assert (match-target-with-tensor-1 '(V (H P) (P))
                                      '(t (i b) (a))
                                      :orbital-spaces
                                      '((H i)
                                        (P b a))))
  (assert (not (match-target-with-tensor-1 '(V (H P) (P))
                                           '(t (i b) (c)) ;; here
                                           :orbital-spaces
                                           '((H i)
                                             (P b a))))))
#+end_src


#+begin_src lisp :tangle gunu.lisp
(defun match-target-with-tensor (target tensor &key orbital-spaces)
  "Here we check that Vaibj is equivalent to Viajb and so on always.
  This is general to all tensors.
  It works for any dimension thanks to permuting all the legs of
  the tensor."
  (let ((all-targets (mapcar (lambda (x) `(,(car target) ;; name
                                                   ,@x)) ;; feet
                             (all-permutations (cdr target)))))
    (loop for tt in all-targets
          thereis (match-target-with-tensor-1
                  tt tensor
                  :orbital-spaces orbital-spaces))))
#+end_src

#+begin_src lisp :tangle t.lisp
(progn
  (assert (match-target-with-tensor '(V (H P) (P H))
                                    '(t (a i) (j b))
                                    :orbital-spaces
                                    '((H i j)
                                      (P b a))))
  (assert (not (match-target-with-tensor '(V (H P) (P H))
                                         '(t (i a) (j b))
                                         :orbital-spaces
                                         '((H i j)
                                           (P b a))))))
#+end_src

* Symmetries

This section discusses how to implement and encode symmetries of the
diagrams.

** Node symmetry
For instance, all operators in quantum chemistry
have a node symmetry whereby exchanging the positions of the electrons
the tensor remains unchanged. For instance, for the coulomb integrals
\( V^{pq}_{rs} \) this is encoded in the relation
\begin{equation*}
V^{pq}_{rs} = V^{qp}_{sr}
\end{equation*}
and from the second-quantization point of view this is also
transposing a pair number of times the \(q\)-operators.

We can encode these properties in lisp by just
saying by which replacements the tensors remain unchanged,
for instance for
#+begin_example
(V (p s) (q r))
#+end_example
we would write as symmetries
#+begin_src lisp :eval no
;; main two-body node symmetry
((p . q) (s . r))
#+end_src

and we can write a simple function to apply this symmetry to tensor nodes
#+begin_src lisp :tangle gunu.lisp
(defun apply-symmetry-to-nodes (symmetry-equivalence object)
  (let* ((temp-symbols (mapcar (lambda (x) (gensym)) symmetry-equivalence))
         (equiv-forward (mapcar (lambda (x y) (cons (cdr x) y))
                                     symmetry-equivalence temp-symbols))
         (equiv-backward (mapcar (lambda (x y) (cons y (car x)))
                                      symmetry-equivalence temp-symbols)))
    (sublis equiv-backward
            (sublis symmetry-equivalence
                    (sublis equiv-forward object)))))
#+end_src

And in fact  it is a very general function that works on every
tree thanks to =sublis=:

#+begin_src lisp :tangle t.lisp
(assert-equal (apply-symmetry-to-nodes '((P . Q) (S . R))
                                       '((P S) (Q R)))
              ;;
              '((Q R) (P S)))

(assert-equal (apply-symmetry-to-nodes '((a . b) (i . j))
                                       '(T (a i) (b j) (c k)))
              ;;
              '(T (B J) (A I) (C K)))

(let ((contraction '((contraction (P2 P5) (H2 H3) (H1 H4) (P1 P3))
                     (V (h1 p1) (h2 p2))
                     (T (p3 h3) (p4 h4))
                     (T (p5 h5)))))
  (destructuring-bind ((cts _ a b c) v tabij tai . nil) (apply-symmetry-to-nodes
                                               '((p3 . p4) (h3 . h4))
                                               contraction)
    (assert-equal tabij '(T (p4 h4) (p3 h3)))
    (assert-equal tai '(t (p5 h5)))
    (assert-equal v '(V (h1 p1) (h2 p2)))
    (assert-equal (list a b c) '((h2 h4) (h1 h3) (p1 p4)))))


(assert-equal (apply-symmetry-to-nodes '((p . q))
                                       '(V (P s) (q r)))
              ;;
              '(V (Q S) (P R)))
#+end_src

Mostly however it is quite tedious to write these equivalences
by hand so we can use the =make-node-symmetry= function to
create a well-named symmetry equivalence.

#+begin_src lisp :tangle gunu.lisp
(defun make-node-symmetry (nodes)
  (let* ((n (length nodes))
         (node-combinations
           (loop for fst below n
                 append (loop for snd from (1+ fst) below n
                              collect (list fst snd)))))
    (mapcar (lambda (combi)
              (apply #'mapcar `(cons ,@(mapcar (lambda (i) (nth i nodes))
                                                 combi))))
            node-combinations)))
#+end_src

And it should of course work for higher dimensional tensors.

#+begin_src lisp :tangle t.lisp
;; fail gracefully for one dimensional diagrams
(assert! (make-node-symmetry '((p q))))

(assert-equal (make-node-symmetry '((p s) (q r)))
              '(((P . Q) (S . R))))

;; and it also works for n-dimensional nodal tensors
(assert-equal (make-node-symmetry '((p1 s1) (p2 s2) (p3 s3)))
              '(((P1 . P2) (S1 . S2)) ;; node 1 <> node 2
                ((P1 . P3) (S1 . S3)) ;; node 1 <> node 3
                ((P2 . P3) (S2 . S3)))) ;; node 2 <> node 3

(assert-equal (make-node-symmetry '((p1 s1) (p2 s2) (p3 s3) (p4 s4)))
              '(((P1 . P2) (S1 . S2))
                ((P1 . P3) (S1 . S3))
                ((P1 . P4) (S1 . S4))
                ((P2 . P3) (S2 . S3))
                ((P2 . P4) (S2 . S4))
                ((P3 . P4) (S3 . S4))))
#+end_src

In the case of a list of tensors
we can define the following function
#+begin_src lisp :tangle gunu.lisp
(defun make-symmetries-in-list (list-of-tensors)
  (thread-last list-of-tensors
               (mapcar #'cdr)
               (mapcar #'make-node-symmetry)
               (reduce #'union)))
#+end_src

#+begin_src lisp :tangle t.lisp
(let* ((tensors '((V (h1 p1) (h2 p2))
                  (T (p3 h3) (p4 h4))
                  (T (p5 h5))))
       (symmetries (make-symmetries-in-list tensors)))
  (assert-equal symmetries
                '(((P3 . P4) (H3 . H4))
                  ((H1 . H2) (P1 . P2)))))
#+end_src



** Filtering diagrams through contractions

Now the question in everyones minds is, wether or not
we can restrict ourselves only to the contractions to apply
the symmetries.

The following is a text depiction of a diagram where
we have numbered the nodes from 1 to 5.
#+begin_src artist
                             hh
                            V              
                             pp            
                     1                    2
                     x--------------------x
                    ---                  ---
                   /   \                /   \
                  /     \              /     \
                  |     |              |     |
  .       .       ^     v              ^     v
   .     .        |     |              |     |
    v   ^         \     /              \     /
     . .           \   /                \   /
      .             ---                  ---
      o==============o                 ===o===
      3              4                    5
             T                               T
              2                               1
                                              
#+end_src


In this case, the contractions will be
#+begin_src lisp :eval no
((h1 h4) (p1 p4) (h2 h5) (p2 p5))
#+end_src

The equivalent diagram linking through bubbles
nodes \( (4, 2) \) and \( (1, 5) \)
would be writted as
#+begin_src lisp :eval no
((h1 h5) (p1 p5) (h2 h4) (p2 p4))
#+end_src

If we are to apply the node symmetry of \( V \)
to this contraction set we will get
the original contraction as depicted in the diagram
and thus it is enough to apply the symmetries
to the contractions.

Indeed, the contractions are the differntiating
element that distinguish diagrams, it is therefore
understandable that through them we can also identify
equal diagrams.

** Filtering contractions through symmetries

Given a set of diagrams, we should decide
which ones are equivalent through a set of symmetries and which ones arent.

The obvious way of checking the diagrams is through looping
through a set of diagrams and a set of symmetries
and check wether or not they are the same in terms of contractions
and in the sense of sets through such a function like
=find-duplicate-set=.

#+begin_src lisp :tangle gunu.lisp
(defun find-duplicate-set (element lst)
  (find element lst :test-not (lambda (-x -y)
                                (set-difference -x -y :test #'equal))))
#+end_src

#+begin_src lisp :tangle t.lisp
(assert-equal (find-duplicate-set '((a . b) (c . d))
                                  '(((c . e) (a . b))
                                    ((c . d) (a . b))
                                    ((a . b) (c . d))))
              '((c . d) (a . b)))
#+end_src

However, this begs the question of given a set of symmetries
as discussed so far, wether it is necessary to compute the minimal
group containing them in order to discover equivalent diagrams.

The symmetry group of a diagram is exactly the product group
of the individual symmetry groups of every piece of the diagram.
Which means that in general we should have to compute the product
group of the symmetry components.
However, since in general we will look for repeated diagrams
in a set of contractions that is already been created by
computing all combinations of contractions, simply computing
the direct sum of the symmetry sets will be enough
for these cases.

In conclusion, the suitable function for filtering
a set of contractions through a set of symmetries (which might
be a group or not) is:

#+begin_src lisp :tangle gunu.lisp
(defun filter-contractions-by-symmetries (symmetries contractions)
  (let ((-contractions (copy-tree contractions)))
    (do (result seen-contractions)
        ((null -contractions) result)
      (let ((c (pop -contractions)))
        (block :sym-searching
          ;; go through all symmetries
          (loop for sym in (cons nil symmetries)
                do (let ((new-c (apply-symmetry-to-nodes sym c)))
                     (when (find-duplicate-set new-c seen-contractions)
                       (push new-c seen-contractions)
                       (format t "~&~a is the same as ~a by virtue of ~a"
                               c new-c sym)
                       (return-from :sym-searching))))
          ;; if I got here, then c is a new contraction
          ;; never seen before
          (push c result)
          (push c seen-contractions))))))
#+end_src


* Contractions

Contraction rules should be something that tells us
which contractions are not zero.
For instance having

#+begin_src lisp :eval no
  (v (j b)) (t (a i))
#+end_src

here we can see that

- =a b= can contract: =(P 1 0)= (i.e. first position and zeroth position)
- =i j= can contract: =(H 0 1)= (i.e. zeroth position and first position)

A contraction is given by the format

#+begin_src lisp :eval no
  ((contraction ((a b)))
   (v (j b)
   (t (a i))))
#+end_src

and we can stich this contraction together to create a tensor
This is done by =contraction-to-temp-tensor=.

#+begin_src lisp :eval no
  ((contraction ((a b)))
   (v (j b)
   (t (a i)))) =>> (tv (j i)) which would match (_ (H H))
#+end_src

** EXPLAIN Mergin nodes

In this section we work on the fact that when
a contraction is made between legs, then these legs
disappear from the resulting tensor object having in general
two legs less, i.e., one node less.

TODO:: Think about why is not possible to contract
       '(a c) '(a b) '(c d)...

#+begin_src lisp :tangle gunu.lisp
(defun stich-together (contraction node-a node-b)
  ;; contraction-assoc: ((c0 . x) (c1 . x))
  (let ((contraction-assoc (mapcar (lambda (x) (cons x 'x)) contraction)))
      (labels ((kill-matching (i) (sublis contraction-assoc i)))
    (let* ((killed-a (kill-matching node-a))
           (pos-a (position 'x killed-a))
           (killed-b (kill-matching node-b))
           (pos-b (position 'x killed-b)))
      (when (or (equal killed-a node-a)
                (equal killed-b node-b))
        (error "The contraction ~a does not link nodes ~a and ~a"
               contraction node-a node-b))
      (if (eq pos-a pos-b) ;; NUCLEAR-TODO
          (error "You are trying to contract ~a and ~a at the same position ~a"
                 node-a node-b pos-a)
          (progn
            (setf (nth pos-a node-a) (car (delete 'x killed-b)))
            node-a))))))
#+end_src

#+RESULTS:
: STICH-TOGETHER

#+begin_src lisp :tangle t.lisp
(assert-equal (stich-together '(a d)
                              '(a b) '(c d))
              '(c b))
(assert-equal (stich-together '(b c)
                              '(a b) '(c d))
              '(a d))

(assert-errmsg (stich-together '(a c) '(a d) '(e f))
               simple-error
               "The contraction (A C) does not link nodes (A D) and (E F)")

(assert-errmsg (stich-together '(e c) '(a d) '(e f))
               simple-error
               "The contraction (E C) does not link nodes (A D) and (E F)")
#+end_src

#+RESULTS:
: NIL



#+begin_src lisp :tangle gunu.lisp
(defun find-and-replace-matching-nodes (contraction tensor-nodes-list
                                        &key killed-pair)
  "tensor-nodes-list is a list of list of nodes"
  (let* ((result (copy-tree tensor-nodes-list))
         (all-nodes-flat (reduce #'append result)))
    (loop for node in all-nodes-flat
          do
             (case (length (intersection node contraction))
               (0 (continue))
               ;; self-contraction
               (2 (return (subst killed-pair node result :test #'equal)))
               ;; usual contraction
               ;; x--<>---
               ;; we should find exactly ONE OTHER PLACE where this
               ;; contraction is linked by the contraction
               ;; otherwise it is an error
               (1 (let ((matching-nodes
                          (remove-if
                           (lambda (x) (or (equal x node)
                                           (not (intersection x contraction))))
                           all-nodes-flat)))
                    (logger "~&current: ~s matching: ~s through: ~s"
                            node matching-nodes contraction)
                    (case (length matching-nodes)
                      (0 (error "Unbound contractiong ~a with ~a"
                                node contraction))
                      (1 (let ((stiched (stich-together contraction
                                                        node
                                                        (car matching-nodes))))
                           (return (subst killed-pair
                                          (car matching-nodes)
                                          (subst stiched node result)))))
                      (t
                       (error "Contraction arity(~a) error ~a contracts with ~a"
                              (length matching-nodes) node matching-nodes)))
                    ))))))
#+end_src

#+RESULTS:
: FIND-AND-REPLACE-MATCHING-NODES

#+begin_src lisp :tangle t.lisp
(macrolet ((assert-eq (index result)
             `(assert (equal (find-and-replace-matching-nodes ,index
                                                                original
                                                                :killed-pair
                                                                '(x x))
                             ,result))))
  (let ((original '(((a b) (c d))
                    ((e f) (g h))
                    ((i j) (k l) (h1 h2)))))

    ;; 0-1 contraction
    (assert-eq '(e h) '(((a b) (c d))
                        ((g f) (x x))
                        ((i j) (k l) (h1 h2))))

    ;; self contraction
    (assert-eq '(k l) '(((a b) (c d))
                        ((e f) (g h))
                        ((i j) (x x) (h1 h2))))

    ;; 1-0 contraction
    (assert-eq '(b k) '(((a l) (c d))
                        ((e f) (g h))
                        ((i j) (X X) (h1 h2))))

    ;; contraction with tripes
    (assert-eq '(a h2) '(((h1 b) (c d))
                         ((e f) (g h))
                         ((i j) (k l) (x x))))

    ;; contraction within the tensor
    (assert-eq '(a d) '(((c b) (X X))
                        ((e f) (g h))
                        ((i j) (k l) (h1 h2))))

    ;; todo: test error messages

    ))
#+end_src

#+RESULTS:
: NIL


This functions is a handy function to get
from a contraction object

#+begin_src lisp :tangle gunu.lisp
(defun get-contracted-nodes (contraction-tensor &key killed-pair)
  ;; todo replace with contraction-p
  (assert (eq (caar contraction-tensor) 'contraction))
  (let ((contracted-nodes (copy-list (mapcar #'cdr (cdr contraction-tensor))))
        (contractions (cadar contraction-tensor)))
    (loop for contraction in contractions
          do
             (setq contracted-nodes
                   (find-and-replace-matching-nodes contraction
                                                    contracted-nodes
                                                    :killed-pair killed-pair)))
    contracted-nodes))
#+end_src

#+RESULTS:
: GET-CONTRACTED-NODES

#+begin_src lisp :tangle t.lisp
(assert-equal (get-contracted-nodes
               '((contraction ((e d) (k j)))
                 (v (a b) (c d))
                 (h (e f) (g h))
                 (l (i j) (k l))) :killed-pair '(x x))
              '(((A B) (C F))
                ((X X) (G H))
                ((I L) (X X))))
#+end_src

#+RESULTS:
: NIL


** Effective temporary tensor

Given a contraction, we will want to know what
kind of tensor it will result when the contraction
gets applied.

#+begin_src lisp :tangle gunu.lisp
(defun get-contracted-temp-tensor (contraction-tensor &key (name 'contracted))
  (let* ((killed-pair '(x x))
         (x-nodes (get-contracted-nodes contraction-tensor
                                        :killed-pair killed-pair))
         (flat-nodes (reduce (lambda (x y) (concatenate 'list x y))
                             x-nodes))
         (cleaned-nodes (remove-if (lambda (x) (equal x killed-pair))
                                   flat-nodes)))
    `(,name ,@cleaned-nodes)))
#+end_src

#+RESULTS:
: GET-CONTRACTED-TEMP-TENSOR

#+begin_src lisp :tangle t.lisp
(assert-equal (get-contracted-temp-tensor
               '((contraction ((e d) (k j)))
                 (v (a b) (c d))
                 (h (e f) (g h))
                 (l (i j) (k l))))
              '(contracted (A B) (C F) (G H) (I L)))

(assert-equal (get-contracted-temp-tensor
               '((contraction ((b a) (j k)))
                 (V (J I) (A B))
                 (T (C K))
                 (R (G L))) :name '|v*t*r|)
              '(|v*t*r| (C I) (G L)))
#+end_src

#+RESULTS:
: NIL

** Contraction discovery
*** Compatible contractions
This routing finds the possible contractions between two nodes.
One could think that one should create all combinations
of legs that belong to the node and then check according to the
contraction rules. In fact, one just has to loop
over the contraction rules and match every time against the two nodes
since the position of the legs are encoded in the description of the
contraction rules.

#+begin_src lisp :tangle gunu.lisp
(defun compatible-contractions (node-a node-b &key
                                                orbital-spaces
                                                contraction-rules)
  (declare (cons node-a) (cons node-b))
  (assert (and (eq (length node-a) 2) (eq (length node-a) (length node-b))))
  (remove-if
   #'null
   (mapcar (lambda (rule)
             (destructuring-bind ((space-a space-b) pos-a pos-b) rule
               (let ((a (nth pos-a node-a))
                     (b (nth pos-b node-b)))
                 (when (and (eq (find-space-name-by-leg a orbital-spaces)
                                space-a)
                            (eq (find-space-name-by-leg b orbital-spaces)
                                space-b))
                   (list a b)))))
           contraction-rules)))
#+end_src

#+RESULTS:
: COMPATIBLE-CONTRACTIONS

#+begin_src lisp :tangle t.lisp
;; test
(let ((spaces '((H I J K L)
                (P A B C D)
                (G G))))

  (let ((rules '(((H H) 0 1)
                 ((P P) 1 0)))
        (values '(((j i) (i a) . nil)
                  ((j i) (i k) . ((j k)))
                  ((a b) (c k) . ((b c)))
                  ((i a) (g l) . ((i l)))
                  ((i j) (k l) . ((i l)))
                  ((i a) (b j) . ((i j) (a b)))
                  ((a i) (j b) . nil)
                  ((a b) (c d) . ((b c))))))
    (loop for (a b . result) in values
          do (assert (equal (compatible-contractions a b
                                                     :orbital-spaces spaces
                                                     :contraction-rules rules)
                            result))))

  (let ((spaces '((H I J K L)
                  (P A B C D)
                  (G G)))
        ;; test with some absurd contraction rules
        (rules '(((H H) 0 1)
                 ((H P) 1 1)
                 ((P H) 0 1)
                 ((P G) 0 0)
                 ((P P) 1 0)))
        (values '(((j i) (i a) . ((i a)))
                  ((j i) (i k) . ((j k)))
                  ((a b) (c k) . ((a k) (b c)))
                  ((a i) (g l) . ((a l) (a g)))
                  ((i j) (k l) . ((i l)))
                  ((i a) (b j) . ((i j) (a b))))))
    (loop for (a b . result) in values
          do (assert (equal (compatible-contractions a b
                                                     :orbital-spaces spaces
                                                     :contraction-rules rules)
                            result)))))
#+end_src

*** Checking for connectedness

To calculate if a diagram is connected, it is not
enough to check if the contractions touch all diagrams,
but we have to check that we can go to any diagram
through a contraction path.

Therefore, we can simply

#+begin_src lisp :tangle gunu.lisp
(defun is-connected-contraction (pair-combination node-pairs &key group-lengths)
  (let* ((psums (mapcar (lambda (ls) (apply #'+ ls))
                        (maplist #'identity (reverse group-lengths))))
         ;; an interval represents a diagram
         (intervals (mapcar #'cons psums (append (cdr psums) '(0))))
         (diagrams-names (mapcar (lambda (i) (cons i (gensym "DIAGRAM-")))
                                 intervals))
         (node-indices (mapcar (lambda (pair-index) (nth pair-index node-pairs))
                               pair-combination)))
    ;; TODO: optimize this...
    (labels ((diagram-of (i)
               (cdr (assoc (find-if (lambda (interval)
                                      (and (> (car interval) i)
                                           (>= i (cdr interval))))
                                    intervals)
                           diagrams-names))))
      (block :main-routine
        (loop
          for node-permutation in (all-permutations node-indices)
          do (let (path)
               (block :current-permutation
                 (tagbody
                    (loop for node in node-permutation
                          do (let ((diagrams (mapcar #'diagram-of node)))
                               (if (equal (intersection diagrams path)
                                          diagrams)
                                   (return-from :current-permutation)
                                   (progn
                                     (setq path
                                           (append
                                            path
                                            (set-difference diagrams path)))
                                     (when (>= (length path)
                                               (length group-lengths))
                                       (return-from :main-routine t))))))
                    ))
               ))))
    ))
#+end_src
#+begin_src lisp :tangle t.lisp
(macrolet ((! (&rest pts)
             `(mapcar (lambda (p)
                        (position p node-pairs :test #'equal)) ',pts)))
  (let ((node-pairs
          '((0 1) (0 2) (0 3) (0 4) (0 5) (0 6) (0 7) (0 8) ;; | 1st -> all
            (1 4) (1 5) (1 6) (1 7) (1 8)    ;; | 2nd diagram -> 3
            (2 4) (2 5) (2 6) (2 7) (2 8)    ;; |
            (3 4) (3 5) (3 6) (3 7) (3 8)))) ;; |

    ;; this contraction only goes from the first diagram to the second
    (assert! (is-connected-contraction (! (0 1) (0 2) (0 3))
                                       node-pairs :group-lengths '(1 3 5)))

    ;; this contraction only goes from the 2nd diagram to the 3rc
    (assert! (is-connected-contraction (! (1 4) (1 6) (3 4) (3 7) (2 6))
                                       node-pairs :group-lengths '(1 3 5)))

    ;; this is quick, it just goes to from 1 to 2 and to 3 directly
    (assert (is-connected-contraction (! (0 1) (2 5))
                                      node-pairs :group-lengths '(1 3 5)))

    ;; this is less quick, it goes from 1 to 2 twice and then goes to 3
    (assert (is-connected-contraction (! (0 1) (0 2) (2 5))
                                      node-pairs :group-lengths '(1 3 5)))))
#+end_src

*** Finding contractions by number of legs
In this routine magic happens.
So we have a target tensor with
  N_t operators
and some product of tensors with N_i operators each.
The number of contractions should be N_c,
so filters for the number of contractions are

  N_c = (Σ_i N_i) - N_t

If we need N_c contractions, we can get up to
N_c pairs of indices, where every index has a single
contraction. Therefore we need all ORDERED
subsets of length up to N_c


Here we apply the norm simply
Find contractions in a product.
Some filters used are the number of contractions

#+begin_example
     2 * N-c = Sum (i) legs(product) - legs(target)
#+end_example

#+begin_src lisp :tangle gunu.lisp
(defun find-contractions-in-product-by-number-of-legs
    (target tensor-list &key
                          orbital-spaces
                          contraction-rules)
  (let* ((N-c (/ (- (length (flatten-list (mapcar #'cdr tensor-list)))
                    (length (flatten-list (cdr target))))
                 2))
         (all-nodes (reduce #'append (mapcar #'cdr tensor-list)))
         (group-lengths (mapcar (lambda (tsr) (length (cdr tsr))) tensor-list))
         ;; '((1 1) (1 2) (2 2)) if length all-nodes = 2
         (node-pairs (get-node-pairs (length all-nodes)
                                     :group-lengths
                                     (unless *allow-self-contractions*
                                       group-lengths)))
         (node-pair-combinations
           (eval `(ordered-subsets-with-repetition ,N-c
                                                   ,(length node-pairs))))
         results)
    (logger "~&============")
    (logger "~&N-contractions: ~s" N-c)
    (logger "~&all nodes: ~s" all-nodes)
    (logger "~&all node-pairs: ~s" node-pairs)
    (logger "~&all combinations (of pairs) : ~s" node-pair-combinations)
    (setq results
          (labels
              ((indexing (indices lst) (mapcar (lambda (i) (nth i lst))
                                               indices)))
            (loop
              for node-pair-combination in node-pair-combinations
              nconcing
              (block :pairs-discovery
                (tagbody
                   (let* ((pairs (indexing node-pair-combination node-pairs))
                          (nodes (mapcar (lambda (x)
                                           (indexing x all-nodes)) pairs))
                          (II 0)
                          top-contractions)
                     (logger "~&combination: ~s pairs: ~s [~s]"
                             node-pair-combination
                             pairs nodes)
                     (incf II)
                     (when *only-connected-diagrams*
                       (unless (is-connected-contraction node-pair-combination node-pairs
                                                         :group-lengths
                                                         group-lengths)
                         (return-from :pairs-discovery)))
                     (loop for pair in pairs
                           collect
                           (let* ((vertices (indexing pair all-nodes))
                                  (conts (compatible-contractions
                                          (car vertices)
                                          (cadr vertices)
                                          :orbital-spaces orbital-spaces
                                          :contraction-rules contraction-rules)))
                             (cond
                               ((null conts) (return-from :pairs-discovery))
                               ((equal conts
                                       (intersection top-contractions conts
                                                     :test #'equal))
                                (logger "~&~30t⇐Exiting since ~a fully in ~a"
                                        conts top-contractions)
                                (return-from :pairs-discovery))
                               (t
                                (logger "~&~8tvertices: ~s" vertices)
                                (logger "~&~24t appending contractions ~s" conts)
                                (push conts top-contractions)))))

                     ;; START FILTERING
                     (return-from :pairs-discovery
                       (let (--result)
                         (mapc (lambda (real-contraction)
                                 ;; photons say: repeated letters must go!
                                 (let ((letters (flatten-list real-contraction)))
                                   (unless (symbols-repeated-p letters)
                                     (pushnew real-contraction
                                              --result
                                              :test-not
                                              (lambda (x y) (set-difference
                                                             x y
                                                             :test #'equal))))))
                               (eval `(cartesian-product
                                       ,@top-contractions)))
                         --result))
                     ))))))
    (remove-if #'null results)
    ))
#+end_src

#+RESULTS:
: FIND-CONTRACTIONS-IN-PRODUCT-BY-NUMBER-OF-LEGS

**** Case study: Vijab with T1 and T2 coupling to singles excitations

Let us illustrage this function with some tests

#+begin_src lisp :tangle t.lisp
(let ((orbital-spaces '((H i j k l m n o h1 h2 h3 h4 h5)
                        (P a b c d e f g p1 p2 p3 p4 p5)))
      (contraction-rules '(((H H) 0 1)
                           ((P P) 1 0))))
  (labels ((with-rules (target tensor)
             (find-contractions-in-product-by-number-of-legs target tensor
                                                             :orbital-spaces
                                                             orbital-spaces
                                                             :contraction-rules
                                                             contraction-rules))
           (with-rules-c (target tensor) (let ((*only-connected-diagrams* t)
                                               (*allow-self-contractions* nil))
                                           (with-rules target tensor))))
    (with-rules-c '(_ (P H) (P H))
      '((V (h1 p1) (h2 p2))
        (T (p3 h3) (p4 h4))
        (T (p5 h5))))
    ))

,#+(or)
'((1 (P2 P5) (H2 H4) (H1 H3) (P1 P3))
  (2 (H2 H5) (P2 P4) (H1 H3) (P1 P3))
  (3 (H2 H5) (P2 P5) (H1 H3) (P1 P3))
  (4 (P2 P5) (H2 H3) (H1 H4) (P1 P3))
  (5 (H2 H5) (P2 P3) (P1 P4) (H1 H3))
  (6 (P2 P5) (H2 H4) (P1 P4) (H1 H3))
  (7 (H2 H5) (P2 P4) (H1 H4) (P1 P3))
  (8 (H2 H5) (P2 P5) (P1 P4) (H1 H3))
  (9 (H2 H5) (P2 P5) (H1 H4) (P1 P3))
  (10 (P2 P4) (H2 H3) (H1 H5) (P1 P3))
  (11 (H2 H4) (P2 P3) (P1 P5) (H1 H3))
  (12 (P2 P5) (H2 H3) (H1 H5) (P1 P3))
  (13 (H2 H5) (P2 P3) (P1 P5) (H1 H3))
  (14 (H2 H4) (P2 P4) (P1 P5) (H1 H3))
  (15 (H2 H4) (P2 P4) (H1 H5) (P1 P3))
  (16 (P2 P5) (H2 H4) (H1 H5) (P1 P3))
  (17 (H2 H5) (P2 P4) (P1 P5) (H1 H3))
  (18 (P2 P5) (H2 H3) (H1 H4) (P1 P4))
  (19 (H2 H5) (P2 P3) (H1 H4) (P1 P4))
  (20 (H2 H5) (P2 P5) (H1 H4) (P1 P4))
  (21 (H2 H3) (P2 P3) (P1 P5) (H1 H4))
  (22 (H2 H3) (P2 P3) (H1 H5) (P1 P4))
  (23 (P2 P4) (H2 H3) (P1 P5) (H1 H4))
  (24 (H2 H4) (P2 P3) (H1 H5) (P1 P4))
  (25 (P2 P5) (H2 H3) (H1 H5) (P1 P4))
  (26 (H2 H5) (P2 P3) (P1 P5) (H1 H4))
  (27 (P2 P5) (H2 H4) (H1 H5) (P1 P4))
  (28 (H2 H5) (P2 P4) (P1 P5) (H1 H4))
  (29 (H2 H3) (P2 P3) (H1 H5) (P1 P5))
  (30 (P2 P4) (H2 H3) (H1 H5) (P1 P5))
  (31 (H2 H4) (P2 P3) (H1 H5) (P1 P5))
  (32 (H2 H4) (P2 P4) (H1 H5) (P1 P5)))

(defun count-duplicates (lst)
  (mapcar (lambda (x)
            (count x lst
                   :test-not (lambda (-x -y)
                           (set-difference -x -y :test #'equal))))
          lst))


(let* ((tensors
         '((V (h1 p1) (h2 p2))
           (T (p3 h3) (p4 h4))
           (T (p5 h5))))
       (symmetries (make-symmetries-in-list tensors))
       (contractions
         '(((P2 P5) (H2 H4) (H1 H3) (P1 P3)) ((H2 H5) (P2 P4) (H1 H3) (P1 P3))
           ((H2 H5) (P2 P5) (H1 H3) (P1 P3)) ((P2 P5) (H2 H3) (H1 H4) (P1 P3))
           ((H2 H5) (P2 P3) (P1 P4) (H1 H3)) ((P2 P5) (H2 H4) (P1 P4) (H1 H3))
           ((H2 H5) (P2 P4) (H1 H4) (P1 P3)) ((H2 H5) (P2 P5) (P1 P4) (H1 H3))
           ((H2 H5) (P2 P5) (H1 H4) (P1 P3)) ((P2 P4) (H2 H3) (H1 H5) (P1 P3))
           ((H2 H4) (P2 P3) (P1 P5) (H1 H3)) ((P2 P5) (H2 H3) (H1 H5) (P1 P3))
           ((H2 H5) (P2 P3) (P1 P5) (H1 H3)) ((H2 H4) (P2 P4) (P1 P5) (H1 H3))
           ((H2 H4) (P2 P4) (H1 H5) (P1 P3)) ((P2 P5) (H2 H4) (H1 H5) (P1 P3))
           ((H2 H5) (P2 P4) (P1 P5) (H1 H3)) ((P2 P5) (H2 H3) (H1 H4) (P1 P4))
           ((H2 H5) (P2 P3) (H1 H4) (P1 P4)) ((H2 H5) (P2 P5) (H1 H4) (P1 P4))
           ((H2 H3) (P2 P3) (P1 P5) (H1 H4)) ((H2 H3) (P2 P3) (H1 H5) (P1 P4))
           ((P2 P4) (H2 H3) (P1 P5) (H1 H4)) ((H2 H4) (P2 P3) (H1 H5) (P1 P4))
           ((P2 P5) (H2 H3) (H1 H5) (P1 P4)) ((H2 H5) (P2 P3) (P1 P5) (H1 H4))
           ((P2 P5) (H2 H4) (H1 H5) (P1 P4)) ((H2 H5) (P2 P4) (P1 P5) (H1 H4))
           ((H2 H3) (P2 P3) (H1 H5) (P1 P5)) ((P2 P4) (H2 H3) (H1 H5) (P1 P5))
           ((H2 H4) (P2 P3) (H1 H5) (P1 P5)) ((H2 H4) (P2 P4) (H1 H5) (P1 P5)))))

  ;; there are no duplicates
  (assert (every (lambda (x) (eq x 1)) (count-duplicates contractions)))
  (let ((sym-conts (filter-contractions-by-symmetries symmetries contractions)))
    (assert-equal sym-conts
                  '(#| 32 |# ((H2 H4) (P2 P4) (H1 H5) (P1 P5))
                    #| 31 |# ((H2 H4) (P2 P3) (H1 H5) (P1 P5))
                    #| 28 |# ((H2 H5) (P2 P4) (P1 P5) (H1 H4))
                    #| 24 |# ((H2 H4) (P2 P3) (H1 H5) (P1 P4))
                    #| 23 |# ((P2 P4) (H2 H3) (P1 P5) (H1 H4))
                    #| 17 |# ((H2 H5) (P2 P4) (P1 P5) (H1 H3))
                    #| 16 |# ((P2 P5) (H2 H4) (H1 H5) (P1 P3))
                    #| 15 |# ((H2 H4) (P2 P4) (H1 H5) (P1 P3))
                    #| 14 |# ((H2 H4) (P2 P4) (P1 P5) (H1 H3))
                    #| 12 |# ((P2 P5) (H2 H3) (H1 H5) (P1 P3))
                    #| 8 |# ((H2 H5) (P2 P5) (P1 P4) (H1 H3))
                    #| 5 |# ((H2 H5) (P2 P3) (P1 P4) (H1 H3))
                    #| 4 |# ((P2 P5) (H2 H3) (H1 H4) (P1 P3))
                    #| 3 |# ((H2 H5) (P2 P5) (H1 H3) (P1 P3))
                    #| 2 |# ((H2 H5) (P2 P4) (H1 H3) (P1 P3))
                    #| 1 |# ((P2 P5) (H2 H4) (H1 H3) (P1 P3))))))
#+end_src

*** Finding contractions by target properties

#+begin_src lisp :tangle gunu.lisp
(defun find-contractions-in-product-by-target
    (target tensor-list &key
                          orbital-spaces
                          contraction-rules)
  (let ((result (find-contractions-in-product-by-number-of-legs
                 target tensor-list :orbital-spaces orbital-spaces
                                    :contraction-rules contraction-rules))
        (all-indices (loop for i in (mapcar #'cdr tensor-list) appending i)))
    (logger "~&CONTRACTIONS TO CHECK: ~a" result)
    (remove-if #'null
     (loop for contraction in result
          collect
          (let* ((contraction-tensor `((contraction ,contraction)
                                       ,@(copy-list tensor-list)))
                 (contracted-tensor (get-contracted-temp-tensor
                                     contraction-tensor)))

            (logger "~&getting-temp-tensor... ~a ~a" contraction tensor-list)

            (if (match-target-with-tensor target
                                          contracted-tensor
                                          :orbital-spaces orbital-spaces)
                contraction
                nil))))))
#+end_src

#+RESULTS:
: FIND-CONTRACTIONS-IN-PRODUCT-BY-TARGET

#+begin_src lisp :tangle t.lisp
(let ((orbital-spaces '((H I J K L h1 h2 h3)
                        (P A B C D p1 p2 p3)
                        (G g)))
      (contraction-rules '(((H H) 0 1)
                           ((P P) 1 0)))
      (|_ H P H| '(_ (G H) (P H)))
      (|P H P H| '(_ (P H) (P H)))
      (|Vhhpp * Tpphh * Tpphh| '((V (i a) (j b))
                                 (T (c k) (d l))
                                 (T (p1 h1) (p2 h2))))
      (|Vhphp * Thp * Rh| '((V (J I) (A B))
                            (T (C K))
                            (R (G L)))))
  (macrolet ((assert-with-env (fun-applied value)
               `(assert
                 (equal
                  ,(concatenate 'list fun-applied '(:orbital-spaces
                                                    orbital-spaces
                                                    :contraction-rules
                                                    contraction-rules))
                        ,value))))

    ;; with self-contractions
    (let ((*allow-self-contractions* t))

      (assert-with-env
       (find-contractions-in-product-by-target |_ H P H| |Vhphp * Thp * Rh|)
       '(((B A) (J I))
         ((B C) (J I))
         ((B A) (J K))
         ((B C) (J K))
         ((B A) (J L))
         ((B C) (J L))))

    (assert-with-env
     (find-contractions-in-product-by-target '(_ (P H))
                                             '((f (a b)) (t (c i))))
     '(((B A)) ((B C))))

    (assert-with-env
     (find-contractions-in-product-by-target '(_ (G H))
                                             '((f (a b)) (t (c i))))
     '())

    (assert-with-env
     (find-contractions-in-product-by-target '(_ (H P))
                                             '((f (a b)) (t (c i))))
     '()))))
#+end_src

#+RESULTS:
: NIL

#+begin_src lisp :tangle gunu.lisp
(defun contract-expressions-by-target
    (target expression &key orbital-spaces contraction-rules)
  (let ((products (expand-expression expression))
        sums)
    (setq sums
          (loop
            for product in products
            appending
            (progn (print product)
                   (let ((contractions
                           (find-contractions-in-product-by-target target product
                                                                   :orbital-spaces
                                                                   orbital-spaces
                                                                   :contraction-rules
                                                                   contraction-rules)))
                     (mapcar (lambda (x) `((contraction ,x) ,@product))
                             contractions)))))
    `(+ ,@sums)))
#+end_src

#+begin_src lisp :tangle t.lisp

(let ((*allow-self-contractions* t))
  (assert-equal
   (contract-expressions-by-target '(_ (P H))
                                   '(* (+ (f (a b)) (f (i j)))
                                     (t (c k)))
                                   :orbital-spaces
                                   '((H i j k)
                                     (P a b c))
                                   :contraction-rules
                                   '(((H H) 0 1)
                                     ((P P) 1 0)))
   '(+ ((CONTRACTION ((B A))) (F (A B)) (T (C K)))
     ((CONTRACTION ((B C))) (F (A B)) (T (C K)))
     ((CONTRACTION ((I J))) (F (I J)) (T (C K)))
     ((CONTRACTION ((I K))) (F (I J)) (T (C K))))))
#+end_src

* Help routines

TOOD: Explain that all indices must be different and so on

#+begin_src lisp :tangle gunu.lisp
(defun space-subseq (&key orbital-spaces from-index)
  (mapcar (lambda (space)
            (handler-case `(,(car space)
                            ,@(subseq (cdr space) from-index))
              (condition ()
                (error (concatenate
                        'string
                        "Dear user: "
                        "When partitioning tensors, all spaces "
                        "should have a long enough length to cut "
                        "through the leg names using from-index. "
                        "~&In this case "
                        "the space ~s needs at least more "
                        "than ~s elements "
                        "BUT it currently has ~s ")
                       space from-index (length (cdr space))))))
          orbital-spaces))
#+end_src

#+RESULTS:
: SPACE-SUBSEQ

#+begin_src lisp :tangle t.lisp
(assert-equal (space-subseq :orbital-spaces '((H 1 2 3 4) (P a b c) (G g g2))
                            :from-index 2)
              '((H 3 4) (P c) (G)))
#+end_src

#+RESULTS:
: NIL

TODO:: Explain how one to do the naming of tensors so that everything works well
#+begin_src lisp :tangle gunu.lisp
(defun name-legs-by-space-name (tensor-description &key orbital-spaces (from-index 0))
  (let ((orbital-spaces-copy (copy-tree
                              (space-subseq :orbital-spaces orbital-spaces
                                            :from-index from-index))))

    `(,(car tensor-description)
      ,@(loop for index-description in (cdr tensor-description)
              collect
              (loop for space-name in index-description
                    collect
                    (let ((space (find-space-by-name space-name orbital-spaces-copy)))
                      (if (cdr space)
                          (pop (cdr space))
                          (error "Not enough leg names given for space ~a~%"
                                 space))))))
    ))
#+end_src

#+RESULTS:
: NAME-LEGS-BY-SPACE-NAME

#+begin_src lisp :tangle t.lisp
(let ((vals '((0 . (t (h1 p1) (p2 h2)))
              (1 . (t (h2 p2) (p3 h3)))
              (2 . (t (h3 p3) (p4 h4))))))
  (loop for (from-index . result) in vals
        do (assert (equal
                    (name-legs-by-space-name
                     '(t (H P) (P H))
                     :orbital-spaces '((H h1 h2 h3 h4) (P p1 p2 p3 p4))
                     :from-index from-index)
                    result))))
#+end_src

#+RESULTS:
: NIL


TODO: Explain the concept of partitioning and the format

#+begin_src lisp :tangle gunu.lisp
(defun partition-tensor (tensor &key orbital-spaces partition (from-index 0))
  (let ((name (car tensor))
        (indices (cdr tensor))
        (orbital-spaces-copy (copy-tree
                              (space-subseq :orbital-spaces orbital-spaces
                                            :from-index from-index)))
        new-indices-unexpanded)
    (setq
     new-indices-unexpanded
     (mapcar
      (lambda (index)
        (mapcar
         (lambda (leg)
           (let* ((space (find-space-by-leg leg orbital-spaces))
                  (space-name (car space))
                  (partition (find space-name partition :key #'car)))
             (if partition
                 ;; we found a partition
                 (mapcar (lambda (-space-name)
                           (let* ((space (find-space-by-name
                                          -space-name
                                          orbital-spaces-copy)))
                             (if (cdr space) ;; available leg names
                                 (pop (cdr space))
                                 (error "Not enough leg names given for space ~a~%"
                                        space))))
                         ;; elements of the partition (e.g H P)
                         (cdr partition))
                 (list leg))))
         index))
      indices))
    (let ((new-indices (eval `(cartesian-product
                               ,@(mapcar (lambda (index-set)
                                           (eval `(cartesian-product ,@index-set)))
                                         new-indices-unexpanded)))))
      `(+ ,@(mapcar (lambda (ids) `(,name ,@ids))
                   new-indices)))))
#+end_src

#+RESULTS:
: PARTITION-TENSOR


#+begin_src lisp :tangle t.lisp :results raw drawer
(let ((orbital-spaces '((PQ p q r s)
                        (H i j k l)
                        (P a b c d)))
      (partition '((PQ H P))))

  (partition-tensor '(f (p q))
                    :orbital-spaces orbital-spaces
                    :partition partition)
  (partition-tensor '(V (p q) (r s))
                    :orbital-spaces orbital-spaces
                    :partition partition))

#+end_src

#+RESULTS:
:results:
(+ (V (I J) (K L)) (V (I J) (K D)) (V (I J) (C L)) (V (I J) (C D)) (V (I B) (K L)) (V (I B) (K D))
   (V (I B) (C L)) (V (I B) (C D)) (V (A J) (K L)) (V (A J) (K D)) (V (A J) (C L)) (V (A J) (C D))
   (V (A B) (K L)) (V (A B) (K D)) (V (A B) (C L)) (V (A B) (C D)))
:end:

* Output formats
** TeX

#+begin_src lisp :tangle gunu.lisp
(defun latex-tensor (tensor)
  (format nil "~a^{~a}_{~a}"
          (car tensor)
          (format nil "~{~a~}" (mapcar #'car (cdr tensor)))
          (format nil "~{~a~}" (mapcar #'cadr (cdr tensor)))))

(defun latex (tensor-expression &optional (stream nil))
  (case (car tensor-expression)
    (+ (format stream "~&( ~{~a~^~%+ ~}~%)" (mapcar #'latex
                                                     (cdr tensor-expression))))
    (* (format nil "~{~a ~}" (mapcar #'latex (cdr tensor-expression))))
    (t (latex-tensor tensor-expression))))

#+end_src

#+RESULTS:
: LATEX

TODO actually to the tests
#+begin_src lisp :tangle t.lisp
(let ((orbital-spaces '((PQ p q r s)
                        (H i j k l)
                        (P a b c d)))
      (partition '((PQ H P))))
  (latex (partition-tensor '(f (p q))
                           :orbital-spaces orbital-spaces
                           :partition partition))
  (latex (partition-tensor '(V (p q) (r s))
                    :orbital-spaces orbital-spaces
                    :partition partition)))
#+end_src

** TODO Dot diagrams

This section defines some utilities to export the diagrams to dot
format so that one can have some rough estimates for the diagrammatic
form of the terms.

#+begin_src lisp
(defpackage :gunu/dot
  (:use :cl))
(in-package :gunu/dot)

(unless (probe-file "penis")
  (sb-posix:mkdir "penis" #x777)
  )
(defun symb (&rest args)
  (intern (format nil "~{~a~}" (cl-user::flatten-list args))))

(defun subgraph (name &rest contents)
  (format nil "~&subgraph cluster_~a {~%~{~t~a~^~%~}~%}" name contents))

(defun declare-legs (tensor)
  (format nil "~{~a~^, ~} [shape = point]"
          (mapcar (lambda (x) (symb (car tensor) x))
                  (cdr tensor))))

(defun contraction-to-graphviz (contraction)
  ;;(assert (cl-user::contraction? contraction))
  (destructuring-bind ((contraction-symbol conts . nil) prods . nil) contraction
    (loop
      for tensor in prods
      collect
      (let ((tname (car tensor)))
        (case tname
          ((v t2) (subgraph tname
                       (declare-legs tensor)))
          (t1 (format nil "~&~tt1 [shape = box, height = 0.02, label=\"\""))))))
  )
(contraction-to-graphviz
 '((contraction ((h1 h5) (p1 p5) (h2 h3)))
   ((V (h1 h2 ) (p1 p2))
    (t1 (p3 h3))
    (t2 (p4 h4) (p5 h5)))))
#+end_src

An example output should be

#+begin_src dot
graph {
  rankdir = TB
  {
    node [width = .3]
    rank = same
    heaven1, heaven2, heaven3, heaven4 [shape = none, label="", height=.01]
  }

  subgraph cluster_v {
    rank = same
    vleft, vright [shape = "point", label=""];
    {
      vleft -- vright [style = dashed]
    }
  }

  subgraph cluster_t2 {
    rank = same
    style = filled
    t2left, t2right [shape = "point", label=""];
  }

  t1 [shape = "box", height=.02, label=""]

  //
  // contractions
  //
  vleft -- t2left [dir = forward]
  vleft -- t2left [dir = back]

  vright -- t1 [dir=back]

  heaven3 -- t2right [dir = forward, label="i"]
  heaven2 -- t2right [dir = back, label="a"]
  heaven4 -- t1 [dir = forward, label="j"]
  heaven1 -- vright [dir = back, label="b"]

}
#+end_src

** TODO SVG
#+begin_src lisp
,#+quicklisp (ql:quickload 'cl-svg)
,#+asdf (asdf:load-system 'cl-svg)

(in-package :cl-svg)


(defvar test-contraction nil)
(setq test-contraction
  '((contraction ((h1 h3) (h2 h4) (p1 p2) (p2 p5)))
    (V (h1 p1) (h2 p2))
    (T1 (p3 h3))
    (T2 (p4 h4) (p5 h3))))

(defun svg-diagram (contraction &key (node-length 50))
  )

(let* ((scene (make-svg-toplevel 'svg-1.1-toplevel :height 250 :width 250)))
  (draw scene (:rect :x 0 :y 0 :height 250 :width 250) :fill "#CCCCCC")
  (text scene (:x 25 :y 25) "this an tahtt and penis"
    (tspan (:fill "red" :font-weight "bold" :font-size "2em") "circle"))
  (draw scene (:circle :cx 200 :cy 20 :r 10) :fill "blue")
  (draw scene (:circle :cx 100 :cy 20 :r 10) :fill "yellow")
  (draw scene (:circle :cx 100 :cy 100 :r 10) :fill "red")
  (draw scene (:circle :cx 200 :cy 100 :r 10) :fill "white")

  (with-open-file (s #p"test.svg" :direction :output :if-exists :supersede)
    (stream-out s scene)))
#+end_src
